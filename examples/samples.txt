//Caspian language features proposal 

//types
bool
null
int
float
str
Array
Map
function
lambda
class
Union
iterator
Type

Union by itself will take anything, Union[type1, type2] will only take type1 or type2

//operators
<
>
>=
<=
+
-
*
/
%
==
!=
|
&
and
or
in
not
as

//literals
true, false (bool)
13, 32323232 (int)
32.23 (float)
-23 (int)
-23.232 (float)
"James", `James Joe Lilly`, 'James Joe'
null

//string formatting
`Hello, {"James"+" Petullo"}`

//array
[1, 3, 4, 5], [[[2, "James", 3.23], null], [true, -32]]
//with await
arr = [1, 3, 4, await func()]

//map
{1:2, "james":10}

//arrays and maps can be made immutable via the '#' character:
arr = #[1, 2, 3, 4]
//accessing works: arr[0]
//but not setting: arr[1] = 10 => raises "Immutable Container Error"
[1, 2, 3, #[1, 34, 3]]
v = #{1:2, 3:42, "james":10}
v['james'] = 1000 =>  "Immutable Container Error"

//1.1 type checking (variable assignment)
val = 10 //no type, can be reassigned to other types (val = "James")
val:int = 10 //can only be assigned integers
val:int[weak=true] = 10 //weak assignment, can be reassigned, but will fail if type checked against i.e if val = "James"; f(val), and f expects and integer

order_of_op = (1+2)*3

//unpacking

a, ..b = [1, 2, 3, 4]
// => a = 1; b = [2, 3, 4]
[[a, ..b], c], ..d = [[[1, 2, 3, 4], 5], 5, 6]
// => a = 1; b = [2, 3, 4]; c = 5; d = [5, 6]
v = [...[3, 4, 5]]
//be able to retain immutability in unpacking
a, ..b = #{1, 2, 3, 4}
//a = 1; b = #{2, 3, 4}
//unpacking maps
a, ...b = {'james':21, 'joe':18, 'lilly':15}
//a = 'james'; b = {'joe':18, 'lilly':15}
//"..." syntax runs a full unpacking and passes it back to an object.create handler
{'james':a}, ...b = {'james':21, 'joe':18, 'lilly':15}
//a = 21; b = {'joe':18, 'lilly':15}


//imports

import file1
import file1 or file2 // => file1 is imported if it is found, else file2. If file2 is not found, an import error is thrown
import file1 as f1
import (file1 or file2) as f
import file1.function1 as f1 // function1 is now stored under the name f1 in this context

//raising exceptions
raise Exception("Some error occured")

//control flow

if statement
    x = 10
elif another_statement
    v = 1000
else
    v = 1000

//inline if-else
val if statement else 10

//switch-case
//switch-case is indended for pattern matching
switch something
    case 10
        something
    case [a, b, c]
        something_else
    case [a, ..b]
        another_thing
    case {'a':a, 'b':c}
        new_thing
        break //break statement used to stop execution flow of switch
    default
        do_something

//suppress-then

suppress
    raise Exception
then status, e
    print(status, e)

suppress TypeError, SyntaxError
    raise TypeError 
then status, e //since TypeError is explicity suppressed, nothing will be passed to the "then" block
    print(status, e)

//suppress does not need a "then" block
suppress TypeError
    raise Exception

//iteration

//for loops:

for i in iterable
    do_something

//unpacking can also be accomplished in for loops:
for {'a':a, 'b':[b, ..c]}, [[j, k], l] in iterable:
    pass

//while loops

do
    something
while condition

while condition
    do_something

while //infinite while-loop, requires return/break to stop it
    do_something
    break

for _ in x:
    if true
        continue //continue jumps the execution back to the top of the loop

//for-loop comprehensions

//array
[i for i in iterable if something]
[i for b in j for i in b]

//map
{a:b for i in iterable if something}

//while loop comprehensions
//lambda function with no params, must return map with keys 'response' and 'variables'
[():map[str, Union[Any, map]]({'response':x + 1, 'variables':{'x':x + 1}}) while x != 3]

//functions

fun get_results(a:int, b:c):int
    return something

fun get_results(a:int[weak=true], b:int[weak=true]):int[weak=true]
    return something_else

fun get_results(a, ..args, ...kwargs):Any
    ... //empty body (pass)

get_results(10, 10, 10, 10, val1=10, val2=10)

fun get_results(a, b = 10, c = 20)
    return

abstract fun test()
    `docstring for test`

abstract fun test()
    pass


fun test()
    return

//abstract has to be overwritten or error will be raised

//chaining calls

x = "James" |> get_length |> compute_factorial

x1 = "james"
    |> get_length
    |> compute_factorial
    |> new_fact(1, 2, _, 3) // result from compute_factorial passed to new_fact at the position of the throwaway variable
    |> final_result(1, 2) //result from new_fact passed to final_result after "2"
    |> unpack_stuff(1, .._) //result from final_result passed to unpack_stuff and unpacked (as an array)



//lambdas

(a:int, b:int, c:int):int(a+b+c) //callable object
f = (a:int, b:int, c:int):int(a+b+c)
(a:int, b:int, c:int):int(a+b+c)(1, 2, 3)

//multiline lambdas
((a, b, c):int[weak=true]
    x = a + b + c
    while true  
        x = x + 1
        if x%3
            break
    return x)(1, 2, 3)


//generators

fun my_gen()
    yield 10
    yield from my_gen()

//decorators
//any callable

@is_loggedin
@route('/blog/<post>', methods=['GET', 'POST'])
fun serve_blog(post)
    return "<h1>this is blog post ({post})</h1>"

//classes
class Node
    fun constructor(val):null
        this.head = val

    fun test_method():int
        return this.head + 1
    
    static fun new_node(val):class
        return Node(val)
  
    //iterator magic method
    fun primative::iterator()
        yield 10
        yield 20
        yield 30
    
    //getitem magic method
    fun primative::getattr(val)
        return val

    //getattr magic method
    fun primative::getattr(val)
        return val

    fun primative::type_check(type_obj:Type)
        if type_obj.class != this.__class__
            return false
        
        return type_obj.type_vals[0] == int

    //all objects will inherit this primative
    static fun primative::type_check(type_obj:Type)
        return type_obj.class == this.__class__

    static abstract fun test()
        return 10

    static abstract async fun test()
        return await this.some_coroutine()


//inheritence

class A inherits B
    fun constructor(val)
        parent().constructor(val)

class A inherits B, C
    fun constructor(val)
        parent(B).constructor(val)
        parent(C).constructor(val+20)

//abstract classes and methods

abstract class A
    abstract fun test()
        `test`

//abstract classes cannot be instantiated

abstract class A
    fun test()
        `test`

a = A() //error raised

//abstract methods cannot be called without being overridden in a child class
class A
    abstract fun test()
        `something`


a = A() //raises Abstract error, because test was not overridden

class B
    abstract* fun test()
        `something`

b = B() // no error raised, test is weak (from the addition of the "*")

//should all objects inherit from an Object class?

//primatives
getitem //supports multiple getitem paramters o[1, 2, 3], o[1, 2, 3:4]
setitem //supports multiple getitem paramters o[1, 2, 3] = 10
getattr
setattr
get
set
eq
ne
lt
le
gt
ge
add
sub
mul
div
iterator
next
type_check
and
or

//for any object o, attaching a primative can be accomplished via o[primative::prim_func]:
o[primative::iterator] = ():iterator
                            yield 10
                            yield 20
                            yield 30

fun iter_add()
    for i in range(10)
        yield i

o[primative::iterator] = iter_add



//async

async fun test()
    ``

async fun main()
    r = await test()

main()

//implicitly, all async objects return a promise object
//Promise(complete:bool, result:Union[null, Any])
//Promise should contain any errors
//when an async function is called, the function is executed and the promise returned.
//if the promise is awaited, the program blocks until the promise's complete attribute is true
//if the promise is not awaited and the complete attribute is false, then it is put back into the message queue and the program execution proceeds
//when a coroutine is put back into the queue, the params originally passed to it are also included
//async for loop:

for i in (await coroute):
    f(i)

//both valid uses of iterator with async

async for i in coroutine:
    f(i)


//await, like yield has to be in function

//run coroutines concurrently

import random.randint as rdnt
import asyncio

async fun get_random()
    await asyncio.sleep(3)
    return rdnt(1, 10)

async fun main()
    return await get_random()

//asyncio.run blocks the rest of the program from running until main has been run
result1 = asyncio.run(main)
//imagine, want to run get_random ten times, but only in 3 seconds total, and get back all get_results
result = asyncio.parallel(..[get_random for _ in range(10)])

